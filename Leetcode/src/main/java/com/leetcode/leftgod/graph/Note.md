# 图

## 遍历

### 宽度优先遍历（广度优先遍历）

> 1、利用队列实现
>
>2、从源节点开始依次按照宽度进队列，然后弹出
>
>3、每弹出一个节点，把该节点所有没有进过队列的邻接点放入队列
>
>4、直到队列变空

### 深度优先遍历

> 1、利用栈实现
>
> 2、从源节点开始依次按照深度放入栈，然后弹出
>
> 3、每弹出一个节点，把该节点的所有没有进过栈的邻接点放入栈
>
> 4、直到栈变空

### 拓扑排序算法

> 1、使用哈希表存储每一个节点剩余的入度数
>
> 2、使用队列存储入度为0的节点
>
> 3、从队列中取出节点
>
> 4、清除此节点影响的所有节点，即将此节点所有的next节点的入度-1
>
> 5、如果存在某个节点的入度为0，则放入队列中

# kruskal 算法 （最小生成树）

要求无向图

> 最小生成树：使用最短长度将所有节点连通
>
> 1、将所有边按照长度排序(优先队列——priorityQueue)
>
> 2、如果将边添加进来是否形成环，如果形成环则放弃，如果未形成环则保留

# prim算法 （最小生成树）

要求无向图

> 最小生成树：使用最短长度将所有节点连通
>
> 1、任取一个节点作为开始，将节点放入集合中
> 
> 2、将相连节点放入集合中，并将相连的边放入优先队列中
> 
> 3、找从队列中最短的边所连接的节点，循环1


# Dijkstra算法 

要求无向图

> 最小生成树：使用最短长度将所有节点连通
>
> 1、任取一个节点作为开始，将节点放入集合中
> 
> 2、将相连节点放入集合中，并将相连的边放入优先队列中
> 
> 3、找从队列中最短的边所连接的节点，循环1
